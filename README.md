# Inserting and deleting from a Randomized Binary Search Tree C++

Рандомизированные деревья поиска (Randomized Binary Search Trees, RBST) представляют собой структуру данных, которая объединяет в себе принципы двоичных деревьев поиска и случайности для поддержания сбалансированности деревьев по вероятностной мере. Основная идея заключается в том, чтобы при каждой операции вставки или удаления вносить элемент случайности, что позволяет дереву адаптироваться и избегать худших сценариев производительности, обычно ассоциируемых с несбалансированными деревьями.

Этот проект фокусируется на разработке эффективных алгоритмов для операций вставки и удаления элементов в рандомизированное дерево поиска.


# Постановка задачи
 - [Создать функцию добавления и удаления элемента в рандомиизированное дерево](https://github.com/SkillBond/Inserting-and-deleting-from-a-Randomized-Binary-Search-Tree-C-/blob/main/ins%26del.cpp)



# Документация

## А что такое бинарное дерево поиска? 

Эта структура помогает сортировать элементы в зависимости от их значения для дальнейшего быстрого их нахождения
Представим что у нас есть список из нескольких чисел, допустим это будет 4 7 -11 11 10,
Возьмем за корень дерева 4 так как оно идет самым первым списке, и является **стволом**, чтоб расположить элементы в дереве мы будем придерживаться правилу: если следующее число меньше предыдущего то оно идет левее, больше правее.
Следуя этому правилу, у нас должна получится эта картина:
![Готовое бинарное дерево](/img/tree.png)
д
*Как я и сказал 4 является **стволом** этого дерева, а все элементы которые находятся в самом верху, будут называться **листвой**

Таким образом мы значем что 10 находится в правой ветке нашего дерева, и это значительно ускоряет нахождение нужного нам элемента потому что мы сразу отсекаем не нужные нам ветки, где значения ниже 
## А что такое рандомизированое бинарное дерево поиска?

Рандомизированная сортировка деревом — это способ упорядочить данные с помощью бинарного дерева поиска. Вначале данные перемешиваются случайным образом, затем они вставляются в дерево, и в результате обхода дерева данные получаются отсортированными
Общий алгоритм рандомизированной сортировки деревом выглядит следующим образом:

* Создать пустое бинарное дерево поиска (BST).
* Перемешать исходный массив случайным образом.
* Поочерёдно вставить все элементы из перемешанного массива в BST.
* Выполнить инфиксный обход BST, который вернёт элементы в отсортированном порядке.
Преимуществом данного метода является то, что среднее время работы алгоритма составляет O(n log n), где n — количество элементов. Однако в худшем случае, если элементы вставляются в уже отсортированном порядке, дерево вырождается в связанный список, и время работы алгоритма становится O(n^2).

Использование рандомизации позволяет уменьшить вероятность худшего случая, но не устраняет её полностью. Для более надёжного обеспечения быстродействия в худшем случае используются балансирующиеся деревья, такие как красно-чёрные деревья или AVL-деревья, но они не связаны напрямую с рандомизированной сортировкой деревом.


# Реализация

Блок определения структуры узла (Node) и конструктора узла:
```
// Узел рандомизированного бинарного дерева
struct Node {
    int key;
    int priority;
    std::unique_ptr<Node> left;
    std::unique_ptr<Node> right;

    // Конструктор узла
    Node(int _key) : key(_key), priority(std::rand()), left(nullptr), right(nullptr) {}
};
```
Блок объявления функций:
```
// Объявление функции insert
std::unique_ptr<Node> insert(std::unique_ptr<Node> root, int key);

// Объявление функции deleteNode
std::unique_ptr<Node> deleteNode(std::unique_ptr<Node> root, int key);

// Объявление функции minValueNode
std::unique_ptr<Node> minValueNode(std::unique_ptr<Node> root);

// Объявление функции printTree
void printTree(Node* root);
```
Блок реализации функции printTree:
```
// Функция печати дерева
void printTree(Node* root) {
    if (root) {
        printTree(root->left.get());
        std::cout << root->key << " ";
        printTree(root->right.get());
    }
}
```
Блок реализации функции вставки в дерево:

```
// Функция вставки нового узла в рандомизированное бинарное дерево
std::unique_ptr<Node> insert(std::unique_ptr<Node> root, int key) {
    auto new_node = std::make_unique<Node>(key); // Создаем новый узел

    if (!root) {
        return new_node;
    }

    if (key < root->key) {
        root->left = insert(std::move(root->left), key); // Рекурсивно вставляем новый узел в левое поддерево
    } else {
        root->right = insert(std::move(root->right), key); // Рекурсивно вставляем новый узел в правое поддерево
    }

    return root;
}
```
Блок реализации функции удаления узла:
```
// Функция удаления узла из рандомизированного бинарного дерева
std::unique_ptr<Node> deleteNode(std::unique_ptr<Node> root, int key) {
    if (!root) {
        return nullptr;
    }

    if (key < root->key) {
        root->left = deleteNode(std::move(root->left), key);
    } else if (key > root->key) {
        root->right = deleteNode(std::move(root->right), key);
    } else {
        if (!root->left || !root->right) {
            auto child = std::move(root->left ? std::move(root->left) : std
```
Блок реализации функции поиска узла с минимальным значением в дереве:

```
// Реализация функции minValueNode
std::unique_ptr<Node> minValueNode(std::unique_ptr<Node> root) {
    while (root->left) {
        root = std::move(root->left);
    }

    return root;
}
```
Блок основной функции программы:
```
// Основная функция программы
int main() {
    std::srand(static_cast<unsigned int>(std::time(nullptr))); 
    // Инициализируем генератор случайных чисел

    std::unique_ptr<Node> root = nullptr;

    // Вставляем элементы
    root = insert(std::move(root), 4);
    root = insert(std::move(root), 7);
    root = insert(std::move(root), -11);
    root = insert(std::move(root), 11);
    root = insert(std::move(root), 10);

    // Удаляем элемент
    root = deleteNode(std::move(root), 7);
    // Если не нужно удалять элемент поставьте 0

    // Печатаем дерево
    printTree(root.get());
    std::cout << std::endl;

    return 0;
}
```
