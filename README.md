# Inserting and deleting from a Randomized Binary Search Tree C++

Рандомизированные деревья поиска (Randomized Binary Search Trees, RBST) представляют собой структуру данных, которая объединяет в себе принципы двоичных деревьев поиска и случайности для поддержания сбалансированности деревьев по вероятностной мере. Основная идея заключается в том, чтобы при каждой операции вставки или удаления вносить элемент случайности, что позволяет дереву адаптироваться и избегать худших сценариев производительности, обычно ассоциируемых с несбалансированными деревьями.

Этот проект фокусируется на разработке эффективных алгоритмов для операций вставки и удаления элементов в рандомизированное дерево поиска.


# Постановка задачи
 - Сравнить преимущества рандомизированного дерева среди других видов сортировок
 - Создать функцию добавления и удаления элемента из рандомиизированного дерева


# Документация

## А что такое бинарное дерево поиска? 

Эта структура помогает сортировать элементы в зависимости от их значения для дальнейшего быстрого их нахождения
Представим что у нас есть список из нескольких чисел, допустим это будет 4 7 -11 11 10,
Возьмем за корень дерева 4 так как оно идет самым первым списке, и является **стволом**, чтоб расположить элементы в дереве мы будем придерживаться правилу: если следующее число меньше предыдущего то оно идет левее, больше правее.
Следуя этому правилу, у нас должна получится эта картина:
![Готовое бинарное дерево](/img/tree.png)
д
*Как я и сказал 4 является **стволом** этого дерева, а все элементы которые находятся в самом верху, будут называться **листвой**

Таким образом мы значем что 10 находится в правой ветке нашего дерева, и это значительно ускоряет нахождение нужного нам элемента потому что мы сразу отсекаем не нужные нам ветки, где значения ниже 
## А что такое рандомизированое бинарное дерево поиска?

Рандомизированная сортировка деревом — это способ упорядочить данные с помощью бинарного дерева поиска. Вначале данные перемешиваются случайным образом, затем они вставляются в дерево, и в результате обхода дерева данные получаются отсортированными
Общий алгоритм рандомизированной сортировки деревом выглядит следующим образом:

* Создать пустое бинарное дерево поиска (BST).
* Перемешать исходный массив случайным образом.
* Поочерёдно вставить все элементы из перемешанного массива в BST.
* Выполнить инфиксный обход BST, который вернёт элементы в отсортированном порядке.
Преимуществом данного метода является то, что среднее время работы алгоритма составляет O(n log n), где n — количество элементов. Однако в худшем случае, если элементы вставляются в уже отсортированном порядке, дерево вырождается в связанный список, и время работы алгоритма становится O(n^2).

Использование рандомизации позволяет уменьшить вероятность худшего случая, но не устраняет её полностью. Для более надёжного обеспечения быстродействия в худшем случае используются балансирующиеся деревья, такие как красно-чёрные деревья или AVL-деревья, но они не связаны напрямую с рандомизированной сортировкой деревом.
## Чем этот вид сортировки лучше?
Для начала сравнения я кратко расскажу о нескольких популярных видов сортировки:

* Сортировка пузырьком (Bubble Sort): Этот алгоритм проходит по списку множество раз, сравнивая каждую пару соседних элементов и меняя их местами, если они находятся в неправильном порядке. Сложность времени в худшем случае - O(n^2).
* Сортировка выбором (Selection Sort): Алгоритм на каждом шаге находит наименьший элемент и помещает его в начало списка. Сложность времени всегда O(n^2).
* Сортировка вставками (Insertion Sort): Проходит по списку, вставляя каждый элемент на свое место среди уже отсортированных элементов. Сложность времени в худшем случае - O(n^2).
* Быстрая сортировка (Quick Sort): Разделяет список на две части относительно опорного элемента, и рекурсивно сортирует каждую часть. Средняя сложность времени - O(n log n), но в худшем случае - O(n^2).
* Сортировка слиянием (Merge Sort): Рекурсивно разделяет список пополам, сортирует каждую половину, а затем объединяет их в отсортированный список. Сложность времени всегда O(n log n).

А теперь сравним чем же уступают другие виды сортировки по сравнению с RBST:

* Сортировка пузырьком. 
Имеет квадратичную сложность времени, что делает его неэффективным для больших  списков. В сравнении с рандомизированным двоичным деревом, сортировка пузырьком требует больше времени.
* Сортировка выбором. 
Также имеет квадратичную сложность времени, что делает его неэффективным на больших объемах данных. В отличие от рандомизированного двоичного дерева, сортировка выбором не может обеспечить оптимальную производительность.
* Сортировка вставками. 
Хотя этот алгоритм немного эффективнее, чем предыдущие два, он все равно имеет квадратичную сложность времени, что делает его менее предпочтительным. Рандомизированное двоичное дерево опять же обеспечивает лучшую производительность.
* Быстрая сортировка.
Эта сортировка в среднем имеет сложность времени O(n log n), что делает ее одним из самых эффективных алгоритмов сортировки. Однако, в худшем случае ее сложность времени становится квадратичной, что делает ее менее предпочтительной по сравнению с рандомизированным двоичным деревом, которое обычно обеспечивает стабильную производительность.
* Сортировка слиянием.
Этот алгоритм также имеет сложность времени O(n log n), что делает его эффективным на практике. Однако, в отличие от рандомизированного двоичного дерева, сортировка слиянием требует дополнительной памяти для слияния списков, что может быть недостатком в некоторых случаях.



Как итог сравнения можно привести что сортировка через рандомизированное двоичное дерево обеспечивает среднюю сложность времени O(n log n) без необходимости дополнительной памяти для сортировки, позволяет эффективно обрабатывать большие объемы данных и обеспечивает стабильную производительность в сравнении с другими алгоритмами.

Таким образом, рандомизированное двоичное дерево может быть предпочтительным выбором для сортировки больших объемов данных, поскольку оно обеспечивает хорошую производительность без значительных недостатков, характерных для других алгоритмов сортировки.

# Реализация

Блок определения структуры узла (Node) и конструктора узла:
```
// Узел рандомизированного бинарного дерева
struct Node {
    int key;
    int priority;
    std::unique_ptr<Node> left;
    std::unique_ptr<Node> right;

    // Конструктор узла
    Node(int _key) : key(_key), priority(std::rand()), left(nullptr), right(nullptr) {}
};
```
Блок объявления функций:
```
// Объявление функции insert
std::unique_ptr<Node> insert(std::unique_ptr<Node> root, int key);

// Объявление функции deleteNode
std::unique_ptr<Node> deleteNode(std::unique_ptr<Node> root, int key);

// Объявление функции minValueNode
std::unique_ptr<Node> minValueNode(std::unique_ptr<Node> root);

// Объявление функции printTree
void printTree(Node* root);
```
Блок реализации функции printTree:
```
// Функция печати дерева
void printTree(Node* root) {
    if (root) {
        printTree(root->left.get());
        std::cout << root->key << " ";
        printTree(root->right.get());
    }
}
```
Блок реализации функции вставки в дерево:

```
// Функция вставки нового узла в рандомизированное бинарное дерево
std::unique_ptr<Node> insert(std::unique_ptr<Node> root, int key) {
    auto new_node = std::make_unique<Node>(key); // Создаем новый узел

    if (!root) {
        return new_node;
    }

    if (key < root->key) {
        root->left = insert(std::move(root->left), key); // Рекурсивно вставляем новый узел в левое поддерево
    } else {
        root->right = insert(std::move(root->right), key); // Рекурсивно вставляем новый узел в правое поддерево
    }

    return root;
}
```
Блок реализации функции удаления узла:
```
// Функция удаления узла из рандомизированного бинарного дерева
std::unique_ptr<Node> deleteNode(std::unique_ptr<Node> root, int key) {
    if (!root) {
        return nullptr;
    }

    if (key < root->key) {
        root->left = deleteNode(std::move(root->left), key);
    } else if (key > root->key) {
        root->right = deleteNode(std::move(root->right), key);
    } else {
        if (!root->left || !root->right) {
            auto child = std::move(root->left ? std::move(root->left) : std
```
Блок реализации функции поиска узла с минимальным значением в дереве:

```
// Реализация функции minValueNode
std::unique_ptr<Node> minValueNode(std::unique_ptr<Node> root) {
    while (root->left) {
        root = std::move(root->left);
    }

    return root;
}
```
Блок основной функции программы:
```
// Основная функция программы
int main() {
    std::srand(static_cast<unsigned int>(std::time(nullptr))); 
    // Инициализируем генератор случайных чисел

    std::unique_ptr<Node> root = nullptr;

    // Вставляем элементы
    root = insert(std::move(root), 4);
    root = insert(std::move(root), 7);
    root = insert(std::move(root), -11);
    root = insert(std::move(root), 11);
    root = insert(std::move(root), 10);

    // Удаляем элемент
    root = deleteNode(std::move(root), 7);
    // Если не нужно удалять элемент поставьте 0

    // Печатаем дерево
    printTree(root.get());
    std::cout << std::endl;

    return 0;
}
```
